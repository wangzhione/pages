# 快速排序

快速排序最早由东尼·霍尔提出的一种排序算法. 在平均状况下, 排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见. 事实上, 快速排序通常明显比其他 Ο(nlogn) 算法更快, 因为它的内部循环 (inner loop) 可以在大部分的架构上很有效率地被实现出来.

快速排序使用分治法 (Divide and conquer) 策略来把一个串行 (list) 分为两个子串行 (sub-lists).

快速排序又是一种分而治之思想在排序算法上的典型应用. 本质上来看, 快速排序应该算是在冒泡排序基础上的递归分治法.

快速排序的名字起的是简单粗暴, 因为一听到这个名字你就知道他存在的意义, 就是快, 而且效率高! 他是处理大数据最快的排序算法之一了.虽然 Worst Case 的时间复杂度达到了 O(n²), 但是在大多数情况下都比平均时间复杂度为 O(nlogn) 的排序算法表现要更好:

> 快速排序的最坏运行情况是 O(n²), 比如说顺序数列的快排. 但他的平均期望时间是 O(nlogn), 且 O(nlogn) 记号中隐含的常数因子很小, 比复杂度稳定等于 O(nlogn) 的归并排序要小很多. 所以, 对绝大多数顺序性较弱的一定量的随机数列而言, 快速排序总是优于归并排序.

## 1. 算法步骤

1. 从数列中挑出一个元素，称为 "基准" (pivot);

2. 重新排序数列, 所有元素比基准值小的摆放在基准前面, 所有元素比基准值大的摆在基准的后面 (相同的数可以到任一边). 在这个分区退出之后, 该基准就处于数列的中间位置. 这个称为分区 (partition) 操作;

3. 递归地 (recursive) 把小于基准值元素的子数列和大于基准值元素的子数列排序;

递归的最底部情形, 是数列的大小是零或一, 也就是永远都已经被排序好了. 虽然一直递归下去, 但是这个算法总会退出, 因为在每次的迭代(iteration)中, 它至少会把一个元素摆到他最后的位置去.

## 2. 动图演示

![动图演示](resources/quickSort.gif)


## 3. C 语言描述

```C
static void sort_quick_partial(int a[], int left, int right) {
    // 通过锚点分割为三部分 不大于 | 锚点 | 不小于
    int low = left, high = right;
    int anchor = a[low];
    do {
        while (low < high && anchor <= a[high])
            high--;
        if (low < high)
            a[low++] = a[high];
        
        while (low < high && anchor >= a[low])
            low++;
        if (low < high)
            a[high--] = a[low];
    } while (low < high);
    a[low] = anchor;

    // 不大于
    if (left < low-1) {
        sort_quick_partial(a, left, low-1);
    }
    // 不小于
    if (low+1 < right) {
        sort_quick_partial(a, low+1, right);
    }
}

void sort_quick(int a[], int len) {
    if (a == NULL || len <= 1) {
        return;
    }

    sort_quick_partial(a, 0, len-1);
}
```

对于非递归版本也非常实在. 把下一次待处理区间 left, right 入栈暂存. 后续弹出继续循环.

```C
static int sort_quick_partition(int a[], int low, int high) {
    // 默认 low 为 pivot 支点
    int pivot = a[low];
    for (;;) {
        // low < high && high -> low 三段式写法, 非常好记
        while (low < high && pivot <= a[high])
            high--;
        if (low >= high)
            break;
        a[low++] = a[high];

        while (low < high && pivot >= a[low])
            low++;
        if (low >= high)
            break;
        a[high--] = a[low];
    }
    a[low] = pivot;
    return low;
}

#include "stackint.h"

void sort_quick_non_recursive(int a[], int len) {
    if (a == NULL || len <= 1) {
        return;
    }

    struct stackint s = stackint_create();

    int left = 0, right = len - 1;
    // push left, right => pop right, left
    stackint_push(&s, left);
    stackint_push(&s, right);
    do {
        right = stackint_pop(&s);
        left = stackint_pop(&s);

        int low = sort_quick_partition(a, left, right);

        // [left, right] -> [left, low-1], [low, low], [low+1, right]
        if (left < low-1) {
            stackint_push(&s, left);
            stackint_push(&s, low-1);
        }
        if (low+1 < right) {
            stackint_push(&s, low+1);
            stackint_push(&s, right);
        }
    } while (stackint_exist(&s));

    stackint_release(&s);
}
```
